#include <M5Unified.h>
#include <math.h>

// === 補正パラメータをここに入力（プログラム1で求めた値） ===
const float mag_offset[3] = { -10.5, 5.2, 3.0 };   // bx, by, bz
const float mag_radius = 47.8;                     // avg_radius（例）
const float mag_scale = 1.0f / mag_radius;         // スケーリング係数
//mag_radius は 楕円体フィッティングで求めた平均半径 に置き換えてください。

void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);

  M5.Imu.begin();
  M5.Lcd.setTextSize(2);
  M5.Lcd.println("Estimating Orientation...");
}

void loop() {
  float ax, ay, az;
  float mx, my, mz;

  if (M5.Imu.getAccel(&ax, &ay, &az) && M5.Imu.getMagnet(&mx, &my, &mz)) {
    // === 磁気センサ補正 ===
    mx = (mx - mag_offset[0]) * mag_scale;
    my = (my - mag_offset[1]) * mag_scale;
    mz = (mz - mag_offset[2]) * mag_scale;

    // === 加速度センサ正規化 ===
    float normA = sqrt(ax * ax + ay * ay + az * az);
    ax /= normA; ay /= normA; az /= normA;

    // === 傾き推定 ===
    float pitch = asin(-ax);  // x軸の傾き
    float roll  = atan2(ay, az);  // y軸の傾き

    // === 傾斜補正済み地磁気ベクトルを使ってYaw推定 ===
    float mx2 = mx * cos(pitch) + mz * sin(pitch);
    float my2 = mx * sin(roll) * sin(pitch) + my * cos(roll) - mz * sin(roll) * cos(pitch);
    float yaw = atan2(-my2, mx2);

    // === 角度に変換（ラジアン→度）===
    pitch *= 180.0 / PI;
    roll  *= 180.0 / PI;
    yaw   *= 180.0 / PI;

    // === 表示 ===
    M5.Lcd.setCursor(0, 30);
    M5.Lcd.fillRect(0, 30, 240, 80, BLACK);
    M5.Lcd.printf("Yaw:   %6.1f deg\n", yaw);
    M5.Lcd.printf("Pitch: %6.1f deg\n", pitch);
    M5.Lcd.printf("Roll:  %6.1f deg\n", roll);
  }

  delay(200);
  M5.update();
}
